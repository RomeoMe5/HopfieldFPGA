import math

#Нейронная сеть Хопфилда

#Кол-во нейронов - 9x9
N = 81

#Кол-во образов - 8
M = 8

#Отношение числа ключевых образов M, которые могут быть запомнены, к числу нейронов сети N
#8 / 81 = 0.099

#Символ для значения нейрона
S = {'-': -1, '1': 1}

#Матрица весовых коэффициентов
J = [[0, 1, 1, 1, 1, 1, 1, 1, 1],
     [1, 0, 1, 1, 1, 1, 1, 1, 1],
     [1, 1, 0, 1, 1, 1, 1, 1, 1],
     [1, 1, 1, 0, 1, 1, 1, 1, 1],
     [1, 1, 1, 1, 0, 1, 1, 1, 1],
     [1, 1, 1, 1, 1, 0, 1, 1, 1],
     [1, 1, 1, 1, 1, 1, 0, 1, 1],
     [1, 1, 1, 1, 1, 1, 1, 0, 1],
     [1, 1, 1, 1, 1, 1, 1, 1, 0]]

#Эталонные образы (8 шт.)
X = [['----1----', '---1-1---', '--1---1--', '-1-----1-', '1-------1', '1-------1', '111111111', '1-------1', '1-------1'], #А
     ['111111111', '1--------', '1--------', '1--------', '111111---', '1--------', '1--------', '1--------', '111111111'], #Е
     ['1-------1', '1------11', '1-----1-1', '1----1--1', '1---1---1', '1--1----1', '1-1-----1', '11------1', '1-------1'], #И
     ['1-------1', '1-------1', '1-------1', '1-------1', '111111111', '1-------1', '1-------1', '1-------1', '1-------1'], #Н
     ['111111111', '1-------1', '1-------1', '1-------1', '1-------1', '1-------1', '1-------1', '1-------1', '1-------1'], #П
     ['111111111', '1-------1', '1--------', '1--------', '1--------', '1--------', '1--------', '1-------1', '111111111'], #С
     ['111111111', '----1----', '----1----', '----1----', '----1----', '----1----', '----1----', '----1----', '----1----'], #Т
     ['-11111111', '1-------1', '1-------1', '1-------1', '-11111111', '---1----1', '--1-----1', '-1------1', '1-------1']] #Я

#Искаженный образ 'Т'
test_shape = ['1-111111-', '---------', '1----1---', '1--1-----', '----1--1-', '1--------', '------1--', '1---1----', '---1-----']

print('\n'.join(test_shape))

def sign(num):
    if num < 0:
        return -1
    elif num > 0:
        return 1
    elif num == 0:
        return 0

def get_key(d, value):
    for k, v in d.items():
        if v == value:
            return k

#Обучение сети
for l in X:
    for b in l:
        for i in range(0, 9):
            for j in range(0, 9):
                if (i == j):
                    J[i][j] = 0
                else:
                    J[i][j] += S.get(b[i]) * S.get(b[j])

for i in J:
    print(i, end='\n')

#Запись в файл весовых коэффициентов
f = open('koef.txt', 'w')
for i in J:
    f.write(str(i) + '\n')
f.close()

#Распознаваемый образ
x = [[0] * 9 for i in range(9)]
for i in range(9):
    for j in range(9):
        x[i][j] = S.get(test_shape[i][j])
print('\nx:')
for i in range(9):
    print(x[i], end='\n')

X1 = [[0] * 9 for i in range(9)]

#Распознавание образа
for k in range(9):
    #print('\ni:', i)
    #t = 0
    for i in range(9):
        t = 0
        for j in range(9):
            #print('\nj:', j)
            #print('J[i][j]:', J[i][j])
            #print('x[i][j]:', x[i][j])
            t += J[i][j] * x[k][i]
            #print('t:', t)
        X1[k][i] = sign(t)
        #print('\nX1[i][j]:', X1[i][j])
    #print()
print('\nX1:')
for i in range(9):
    for j in range(9):
        print(get_key(S, X1[i][j]), end='')
    print()
